<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Boa Constructor Introduction - Alec Benson</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../favicon.png><link rel=stylesheet href=../../css/style.min.3383cdd42e33172d122bb505c3de7fd43375315c431e6e19435b40eb7eb0ac49.css><meta name=description content="An introduction to my thesis, Boa Constructor. Also provides links and references necessary to understand and work with it. "><meta property="og:title" content="Boa Constructor Introduction"><meta property="og:type" content="website"><meta property="og:url" content="/posts/boa_constructor/"><meta property="og:description" content="An introduction to my thesis, Boa Constructor. Also provides links and references necessary to understand and work with it. "><meta name=twitter:card content="summary"><meta name=twitter:site content="@benson_alec21"><meta name=twitter:creator content="@benson_alec21"><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel=stylesheet></head><body class="page frame page-blog-single"><div id=wrapper class=wrapper><div class=header><a class=header-logo href=../../>Alec Benson</a><div class=menu-main><ul><li class=menu-item-posts><a href=../../posts/>Posts</a></li></ul></div></div><div class=blog><div class=intro><h1>Boa Constructor Introduction<span class=dot>.</span></h1></div><div class=content><h2 id=background>Background</h2><p>Boa Constructor is an extension oriented compiler frontend for the Python programming language. It works primarily through the definition of translation grammars, which define the original and translated version of the language and can be composed easily. Boa Constructor is an additional frontend for Python that parses the file, outputs its translation, and then runs the translation through a standard Python interpreter. Boa Constructor builds a parse tree of the input file, translates each component node by node, and then outputs this code for execution. In order to work with this properly, I would suggest that you have some understanding of grammars and automata. If necessary, please take a moment to review the links in resources.</p><h2 id=translation-grammars>Translation Grammars</h2><p>Translation grammars are styled in the same way the official Python grammar is and uses a mixture of EBNF and PEG features. Translation grammars can be left recursive, and each rule is formatted as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ruleName: ruleContents { translationDefinition } 
</span></span><span class=line><span class=cl>        | alternativeContents { translationDefinition }
</span></span></code></pre></div><p>Rule names are typically in camel case (although this is a style choice, not a requirement). The rule contents (and alternative contents) are rule definitions that can contain literal strings (":"), tokens (in all capital letters, defined in the Python standard library Tokenize package), and other rule names. As well as this, ruleContents can use positive and negative lookaheads (denoted with & and !), optional blocks (either denoted by square brackets around some contents, or a question mark (?) following the optional contents), repetitions (with * denoting any number of repetitions, and + denoting more than 1 repetition), groups (some section of ruleContents wrapped in parentheses), and cuts (denoted with ~) that tell the parser to commit to that rule even if it fails.<br>Translation definitions can include string literals, the special TABBED and ENDTABBED tokens (denoting that contents inside should be tabbed in a level), the STARTLOOP and ENDLOOP tokens (denoting that you should loop until any inner contents are empty), and the OPTIONAL and ENDOPTIONAL tokens (denoting that the section inside does not have to have contents). As well as these special tokens, the power in translations comes directly from accessing the inner children of that parse node, which is done by starting a variable name with _ and following this with some letter in the English alphabet from a to z. This letter represents which variable in the parse nodes children you&rsquo;re accessing, with a representing the first child and z representing the 26th child. As well as this, you can index components of that child node by using [index, subindex] (specifically useful when you&rsquo;re accessing something that was part of a group). These translation definitions are quite powerful and can be used to build fully functioning translations from a parse node.<br>An example of a rule is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>assignment:
</span></span><span class=line><span class=cl>    | NAME &#39;:&#39; expression [&#39;=&#39; annotated_rhs ] { _a &#34;:&#34; _b } 
</span></span><span class=line><span class=cl>    | single_target augassign ~ (yield_expr | star_expressions) { _a _b }
</span></span></code></pre></div><p>Another example of a rule with a translation follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>list:
</span></span><span class=line><span class=cl>    | &#39;[&#39; [star_named_expressions] &#39;]&#39; { &#34;[&#34; OPTIONAL _a ENDOPTIONAL &#34;]&#34; }
</span></span></code></pre></div><p>In this example, the first alternative is the traditional Python 3.10 list, in which the resulting translation (and original syntax) is defined in the translation.
Actual extensions in Boa Constructor are Python files that contain a multiline string called &ldquo;extension&rdquo;, that contains
the actual rule contents, and a list of strings called keywords contains any necessary keywords for the extension. Keywords are any strings that are used directly as strings in a grammar rule, in the first example below these are true and false, as they need to be parsed differently from generic strings in a programming language.
An example of a full extension is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>extension = &#34;&#34;&#34;
</span></span><span class=line><span class=cl>atom:
</span></span><span class=line><span class=cl>    | NAME { _a } 
</span></span><span class=line><span class=cl>    | &#39;True&#39; { &#34;True&#34; } 
</span></span><span class=line><span class=cl>    | &#39;False&#39; { &#34;False&#34; }
</span></span><span class=line><span class=cl>    | &#39;true&#39; { &#34;True&#34; }
</span></span><span class=line><span class=cl>    | &#39;false&#39; { &#34;False&#34; }
</span></span><span class=line><span class=cl>    | &#39;None&#39; { &#34;None&#34; }
</span></span><span class=line><span class=cl>    | strings { _a } 
</span></span><span class=line><span class=cl>    | NUMBER { _a } 
</span></span><span class=line><span class=cl>    | (tuple | group | genexp) { _a } 
</span></span><span class=line><span class=cl>    | (list | listcomp) { _a[0] } 
</span></span><span class=line><span class=cl>    | (dict | set | dictcomp | setcomp) { _a } 
</span></span><span class=line><span class=cl>    | &#39;...&#39; { &#34;...&#34; }
</span></span><span class=line><span class=cl>&#34;&#34;&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>keywords = [
</span></span><span class=line><span class=cl>    &#34;&#39;true&#39;&#34;,
</span></span><span class=line><span class=cl>    &#34;&#39;false&#39;&#34;,
</span></span><span class=line><span class=cl>]
</span></span></code></pre></div><p>This extension allows a user to type true and false with entirely lowercase letters and Python to accept these as valid proxies for the True and False boolean keywords.
Another example of a full extension:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>extension = &#34;&#34;&#34;
</span></span><span class=line><span class=cl>list:
</span></span><span class=line><span class=cl>    | &#39;[&#39; [star_named_expressions] &#39;]&#39; { &#34;[&#34; OPTIONAL _a ENDOPTIONAL &#34;]&#34; }
</span></span><span class=line><span class=cl>    | &#39;[&#39; NUMBER &#39;::&#39; NUMBER &#39;]&#39; { &#34;[&#34; _a &#34;]&#34; &#34;*&#34; _b }
</span></span><span class=line><span class=cl>&#34;&#34;&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>keywords = [
</span></span><span class=line><span class=cl>    &#34;&#39;::&#39;&#34;,
</span></span><span class=line><span class=cl>]
</span></span></code></pre></div><p>This extension allows the user to type <code>[3::4]</code> which creates a list containing 4 integers with a value of 3. So, the translation takes the first returned value (the number, _a) and the second returned value (the number, _b) and translates this to <code>[NUMBER] * NUMBER</code> or in our example <code>[3] * 4</code></p><h2 id=survey-setup>Survey Setup</h2><p>You will be provided with a link to a replit online programming environment, and a link to the form for this survey. We ask that you spend 30 minutes trying to implement an extension, which is an extension to the list rule in Python&rsquo;s regular grammar. This rule should take input in the form <code>[1...10]</code> and convert this to <code>range(1, 10)</code>
Note that the numbers in this should be dynamic. In your replit environment, you should have a file called &ldquo;rust_range.py&rdquo; that is in the extensions folder. You&rsquo;ll be editing this file for this experiment. When you run the code with the &ldquo;run&rdquo; button, it should raise an error saying that</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>AttributeError: &#39;NoneType&#39; object has no attribute &#39;translate&#39;
</span></span></code></pre></div><p>This means that the extension is not implemented. When you edit the file &ldquo;rust_range.py&rdquo; and run, you will know it has succeeded when an error is not thrown.</p><h2 id=resources>Resources</h2><ul><li>Link 1</li><li>Link 2</li><li>Link 3</li></ul></div></div><div class=footer><div class=footer-social><span class="social-icon social-icon-twitter"><a href=https://twitter.com/benson_alec21 title=twitter target=_blank rel=noopener><img src=../../images/social/twitter.svg width=24 height=24 alt=twitter></a></span>
<span class="social-icon social-icon-github"><a href=https://github.com/bensonalec title=github target=_blank rel=noopener><img src=../../images/social/github.svg width=24 height=24 alt=github></a></span>
<span class="social-icon social-icon-linkedin"><a href=https://www.linkedin.com/in/bensonalec21 title=linkedin target=_blank rel=noopener><img src=../../images/social/linkedin.svg width=24 height=24 alt=linkedin></a></span></div></div></div><script type=text/javascript src=../../js/bundle.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.js></script></body></html>